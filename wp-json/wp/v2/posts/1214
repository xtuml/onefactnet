{"id":1214,"date":"2019-11-21T20:24:17","date_gmt":"2019-11-21T20:24:17","guid":{"rendered":"http:\/\/onefact-migrate.zipfish-sites.io\/?p=1214"},"modified":"2020-12-16T16:10:08","modified_gmt":"2020-12-16T16:10:08","slug":"requirement-tracing","status":"publish","type":"post","link":"https:\/\/onefact.net\/requirement-tracing\/","title":{"rendered":"Requirement Tracing"},"content":{"rendered":"\r\n<figure class=\"wp-block-image\"><img alt='req_tracing-3483090' class=\"wp-image-1213\" src='https:\/\/onefact.net\/wp-content\/uploads\/2019\/11\/req_tracing-3483090.png' alt=\"\" \/><\/figure>\r\n\r\n\r\n\r\n<h2 class=\"wp-block-heading\" id=\"_three_ways_to_do_requirements_tracing_in_xtuml\"><em>three ways to do requirements tracing in xtUML<\/em><\/h2>\r\n\r\n\r\n\r\n<p>Here is a summary of three fundamental approaches to requirements tracing. These apply whether using DOORS, Jama, ReqTracer, Jira, Bugzilla, Redmine or others with similar &#8220;requirement identifier&#8221; approaches.<\/p>\r\n\r\n\r\n\r\n<p>Summary:<\/p>\r\n\r\n\r\n\r\n<ol class=\"wp-block-list\">\r\n<li>imbedding requirement keys into xtUML models using BridgePoint<\/li>\r\n<li>adding xtUML model keys into the requirements of the trace tool<\/li>\r\n<li>imbedding requirements keys into xtUML models during commits using configuration management<\/li>\r\n<\/ol>\r\n\r\n\r\n\r\n<p>Details:<\/p>\r\n\r\n\r\n\r\n<ol class=\"wp-block-list\">\r\n<li>Assuming you have a set of requirements defined in the requirements tracing tool, you can manually imbed (by editing the model) the requirement identifier in Description fields for model elements in BridgePoint. The requirements tracing tool can find and follow these keys in the textual files of your persisted BridgePoint models. This is simple and straight-forward but involves a bit of manual editing.<\/li>\r\n<li>Model elements in BridgePoint have various identifiers. A UUID is automatically created for each model element. Elements have &#8220;fully qualified paths&#8221;. These can be extracted and imbedded\/linked to your requirements tracing tool requirement list. After that, the requirements tracing tool can track and correlate as in method 1.<\/li>\r\n<li>My preference is to use key pairs during commits. Starting with requirements in your requirements tracing tool, the requirement identifier(s) is associated with the feature branch in your configuration management. As each commit is made (to model, code or docs), the requirement key is supplied. This approach allows a particular requirement to trace model artifacts, hand-craft code artifacts and design notes in a coherent and consistent fashion. In our work, we are able to trace every change to its requirement for both features and bugs. Each and every delta to our source artifacts is linked to the initiating requirement.<\/li>\r\n<\/ol>\r\n\r\n\r\n\r\n<p>There are other approaches. Requirements tracing tools I have used in the past can correlate artifacts in other ways. However, it is crucial to understand the goals of your tracing and how your existing flow operates.<\/p>\r\n","protected":false},"excerpt":{"rendered":"<p>three ways to do requirements tracing in xtUML Here is a summary of three fundamental approaches to requirements tracing. These apply whether using DOORS, Jama, ReqTracer, Jira, Bugzilla, Redmine or others with similar &#8220;requirement identifier&#8221; approaches. Summary: imbedding requirement keys into xtUML models using BridgePoint adding xtUML model keys into the requirements of the trace [&hellip;]<\/p>\n","protected":false},"author":3,"featured_media":1213,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"_jetpack_memberships_contains_paid_content":false,"footnotes":""},"categories":[1],"tags":[],"class_list":["post-1214","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-uncategorized"],"jetpack_featured_media_url":"","jetpack_sharing_enabled":true,"_links":{"self":[{"href":"https:\/\/onefact.net\/wp-json\/wp\/v2\/posts\/1214","targetHints":{"allow":["GET"]}}],"collection":[{"href":"https:\/\/onefact.net\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/onefact.net\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/onefact.net\/wp-json\/wp\/v2\/users\/3"}],"replies":[{"embeddable":true,"href":"https:\/\/onefact.net\/wp-json\/wp\/v2\/comments?post=1214"}],"version-history":[{"count":3,"href":"https:\/\/onefact.net\/wp-json\/wp\/v2\/posts\/1214\/revisions"}],"predecessor-version":[{"id":1478,"href":"https:\/\/onefact.net\/wp-json\/wp\/v2\/posts\/1214\/revisions\/1478"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/onefact.net\/wp-json\/"}],"wp:attachment":[{"href":"https:\/\/onefact.net\/wp-json\/wp\/v2\/media?parent=1214"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/onefact.net\/wp-json\/wp\/v2\/categories?post=1214"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/onefact.net\/wp-json\/wp\/v2\/tags?post=1214"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}